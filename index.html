<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEURAL LINK // P2P SYSTEM</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- PeerJS for WebRTC -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <!-- Three.js for 3D Background -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap');

        body {
            background-color: #000;
            color: #0f0;
            font-family: 'Share Tech Mono', monospace;
            overflow: hidden; /* Prevent body scroll, handle in app */
            touch-action: manipulation;
        }

        .sci-fi-border {
            border: 1px solid rgba(0, 255, 65, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.1);
            backdrop-filter: blur(4px);
            background: rgba(0, 10, 0, 0.85);
        }

        .sci-fi-input {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff41;
            color: #00ff41;
            font-family: 'Share Tech Mono', monospace;
        }
        .sci-fi-input:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.4);
        }

        .sci-fi-btn {
            background: linear-gradient(180deg, rgba(0,40,0,1) 0%, rgba(0,20,0,1) 100%);
            border: 1px solid #00ff41;
            color: #00ff41;
            text-transform: uppercase;
            transition: all 0.2s;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .sci-fi-btn:hover {
            background: #00ff41;
            color: #000;
            box-shadow: 0 0 20px #00ff41;
        }
        .sci-fi-btn:active {
            transform: scale(0.95);
        }
        .sci-fi-btn:disabled {
            border-color: #333;
            color: #333;
            background: #000;
            cursor: not-allowed;
            box-shadow: none;
        }

        .recording-pulse {
            animation: pulse-red 1s infinite;
            background: #400000;
            border-color: #ff0000;
            color: #ff0000;
        }
        
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        .scan-line {
            width: 100%;
            height: 2px;
            background: rgba(0, 255, 65, 0.5);
            position: absolute;
            z-index: 10;
            animation: scan 4s linear infinite;
            pointer-events: none;
        }

        @keyframes scan {
            0% { top: 0%; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }

        .message-bubble {
            max-width: 90%; /* Wider on mobile */
            word-wrap: break-word;
            animation: fadeIn 0.3s ease;
        }
        
        @media (min-width: 768px) {
            .message-bubble { max-width: 75%; }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #001100; }
        ::-webkit-scrollbar-thumb { background: #004400; border: 1px solid #00ff41; }

        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        .tab-active {
            background: #00ff41;
            color: #000;
            font-weight: bold;
        }

        /* Video Call Styles - Mobile Optimized */
        .video-overlay {
            position: fixed; /* Fixed to cover everything */
            inset: 0;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .video-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }
        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Fill screen on mobile */
        }
        .local-video {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 100px;
            height: 140px;
            object-fit: cover;
            border: 2px solid #00ff41;
            background: #000;
            z-index: 60;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
        }
        .call-controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 60;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 30px;
            border: 1px solid rgba(0,255,65,0.3);
        }
        .call-btn-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0,0,0,0.8);
        }
        .call-btn-circle:active {
            transform: scale(0.9);
        }
        
        .loader {
            border: 2px solid #003300;
            border-top: 2px solid #00ff41;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-bar-container {
            width: 100%;
            height: 4px;
            background: #002200;
            margin-top: 4px;
            position: relative;
        }
        .progress-bar {
            height: 100%;
            background: #00ff41;
            transition: width 0.2s;
        }
    </style>
</head>
<body>

    <canvas id="bg-canvas"></canvas>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- 3D Background Component ---
        const ThreeBackground = () => {
            useEffect(() => {
                const canvas = document.getElementById('bg-canvas');
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

                const geometry = new THREE.IcosahedronGeometry(8, 2);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x004400, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.2
                });
                const globe = new THREE.Mesh(geometry, material);
                scene.add(globe);

                const particlesGeometry = new THREE.BufferGeometry();
                const particlesCount = 400;
                const posArray = new Float32Array(particlesCount * 3);
                for(let i = 0; i < particlesCount * 3; i++) {
                    posArray[i] = (Math.random() - 0.5) * 40;
                }
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                const particlesMaterial = new THREE.PointsMaterial({
                    size: 0.05,
                    color: 0x00ff41,
                    transparent: true,
                    opacity: 0.6
                });
                const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
                scene.add(particlesMesh);

                camera.position.z = 12;

                const animate = () => {
                    requestAnimationFrame(animate);
                    globe.rotation.y += 0.002;
                    globe.rotation.x += 0.001;
                    particlesMesh.rotation.y -= 0.0005;
                    renderer.render(scene, camera);
                };
                animate();

                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);
            return null;
        };

        // --- Main App Component ---
        const App = () => {
            const [myPeerId, setMyPeerId] = useState(null);
            const [targetPeerId, setTargetPeerId] = useState('');
            const [conn, setConn] = useState(null);
            const [status, setStatus] = useState('INITIALIZING NEURAL NET...');
            const [messages, setMessages] = useState([]);
            const [inputMsg, setInputMsg] = useState('');
            const [mobileView, setMobileView] = useState('connect'); 
            const [isRecording, setIsRecording] = useState(false);
            const [isConnecting, setIsConnecting] = useState(false);
            const [uploadProgress, setUploadProgress] = useState(0);
            
            // Call State
            const [callStatus, setCallStatus] = useState('idle'); // idle, calling, ringing, connected
            const [incomingCall, setIncomingCall] = useState(null);
            const [localStream, setLocalStream] = useState(null);
            const [remoteStream, setRemoteStream] = useState(null);

            const peerRef = useRef(null);
            const messagesEndRef = useRef(null);
            const mediaRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);
            const localVideoRef = useRef(null);
            const remoteVideoRef = useRef(null);
            const currentCallRef = useRef(null);
            const connectionTimeoutRef = useRef(null);
            
            // Data Handling Refs
            const fileChunksRef = useRef({});
            const sendQueueRef = useRef([]); // Queue for outgoing chunks
            const isSendingRef = useRef(false); // Flag to prevent concurrency

            // Audio for effects
            const playSound = (type) => {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                const now = ctx.currentTime;
                if (type === 'send') {
                    osc.frequency.setValueAtTime(800, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                } else if (type === 'receive') {
                    osc.frequency.setValueAtTime(1200, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                } else if (type === 'ring') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(800, now);
                    osc.frequency.setValueAtTime(600, now + 0.2);
                    osc.frequency.setValueAtTime(800, now + 0.4);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 1);
                    osc.start(now);
                    osc.stop(now + 1);
                }
            };

            const initializePeer = useCallback(() => {
                if (peerRef.current) {
                    peerRef.current.destroy();
                }

                const peer = new Peer(undefined, {
                    debug: 1, 
                    config: {
                        'iceServers': [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });

                peer.on('open', (id) => {
                    setMyPeerId(id);
                    setStatus('SYSTEM ONLINE. WAITING FOR LINK...');
                    setIsConnecting(false);
                });

                peer.on('connection', (connection) => {
                    setupConnection(connection);
                    setStatus(`INBOUND LINK: ${connection.peer.substr(0,5)}...`);
                    playSound('connect');
                    setMobileView('chat');
                });

                peer.on('call', (call) => {
                    setIncomingCall(call);
                    setCallStatus('ringing');
                    playSound('ring');
                });

                peer.on('error', (err) => {
                    console.error("Peer Error:", err);
                    setIsConnecting(false);
                    if (err.type === 'peer-unavailable') {
                        setStatus('ERROR: TARGET ID NOT FOUND / OFFLINE');
                        setTimeout(() => {
                            if (!conn) setStatus('SYSTEM ONLINE. WAITING FOR LINK...');
                        }, 4000);
                    } else if (err.type === 'disconnected') {
                         setStatus('NET LOSS. ATTEMPTING RECONNECT...');
                         peer.reconnect();
                    } else {
                        setStatus(`ERROR: ${err.type ? err.type.toUpperCase() : 'UNKNOWN'}`);
                    }
                });

                peer.on('disconnected', () => {
                    if (!peer.destroyed) {
                         setStatus('DISCONNECTED. RECONNECTING...');
                         peer.reconnect();
                    }
                });

                peerRef.current = peer;
            }, []);

            useEffect(() => {
                initializePeer();
                return () => { if (peerRef.current) peerRef.current.destroy(); };
            }, [initializePeer]);

            useEffect(() => {
                if (localVideoRef.current && localStream) {
                    localVideoRef.current.srcObject = localStream;
                    localVideoRef.current.play().catch(e => console.log("Auto-play blocked (local)", e));
                }
            }, [localStream, callStatus]);

            useEffect(() => {
                if (remoteVideoRef.current && remoteStream) {
                    remoteVideoRef.current.srcObject = remoteStream;
                    remoteVideoRef.current.play().catch(e => console.log("Auto-play blocked (remote)", e));
                }
            }, [remoteStream, callStatus]);

            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messages, mobileView]);

            const setupConnection = (connection) => {
                if (connectionTimeoutRef.current) {
                    clearTimeout(connectionTimeoutRef.current);
                    connectionTimeoutRef.current = null;
                }

                connection.on('open', () => {
                    setConn(connection);
                    setStatus('SECURE ENCRYPTED CHANNEL ESTABLISHED.');
                    setIsConnecting(false);
                    playSound('connect');
                    setMobileView('chat');
                });

                connection.on('data', (data) => {
                    handleIncomingData(data);
                });

                connection.on('close', () => {
                    setConn(null);
                    setStatus('LINK SEVERED. TARGET LOST.');
                    setIsConnecting(false);
                });

                connection.on('error', (err) => {
                    console.error("Conn Error", err);
                    setStatus('CONNECTION ERROR');
                    setIsConnecting(false);
                });
            };

            // --- SEND QUEUE PROCESSOR ---
            // This ensures we don't flood the connection
            const processSendQueue = async () => {
                if (isSendingRef.current || sendQueueRef.current.length === 0) return;
                
                isSendingRef.current = true;
                const { payload, onProgress } = sendQueueRef.current.shift();

                try {
                    if (conn && conn.open) {
                        conn.send(payload);
                        // Small delay to yield to the event loop and allow buffering
                        await new Promise(resolve => setTimeout(resolve, 10)); 
                        if (onProgress) onProgress();
                    }
                } catch (e) {
                    console.error("Send failed", e);
                    // Optionally requeue or drop
                }

                isSendingRef.current = false;
                if (sendQueueRef.current.length > 0) {
                    processSendQueue(); // Continue processing
                }
            };

            const queueSend = (payload, onProgress) => {
                sendQueueRef.current.push({ payload, onProgress });
                processSendQueue();
            };

            // --- SAFE SEND FUNCTION (CHUNKING) ---
            const sendSmart = async (data) => {
                const CHUNK_SIZE = 4096; // 4KB - Extremely safe limit for all browsers
                const content = data.content || '';
                
                // If it's small enough, send directly (but still queue it)
                if (content.length < CHUNK_SIZE) {
                    queueSend(data);
                    setMessages(prev => [...prev, { ...data, self: true }]);
                    playSound('send');
                    return;
                }

                // Large file: Chunk it
                const transferId = Math.random().toString(36).substr(2, 9);
                const totalChunks = Math.ceil(content.length / CHUNK_SIZE);
                
                setUploadProgress(0);
                
                // Send metadata first (optional, but we handle it in last chunk for simplicity)
                
                // Chunk loop
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * CHUNK_SIZE;
                    const end = start + CHUNK_SIZE;
                    const chunk = content.slice(start, end);
                    
                    const chunkPayload = {
                        type: 'CHUNK',
                        id: transferId,
                        current: i,
                        total: totalChunks,
                        data: chunk,
                        // Attach metadata only to the final chunk
                        meta: i === totalChunks - 1 ? { ...data, content: null } : null
                    };

                    // Queue the chunk
                    queueSend(chunkPayload, () => {
                        // Update progress only for the sender UI
                        if (i % 10 === 0 || i === totalChunks - 1) {
                            const pct = Math.round(((i + 1) / totalChunks) * 100);
                            setUploadProgress(pct);
                            if (pct === 100) setTimeout(() => setUploadProgress(0), 1000);
                        }
                    });
                }

                // Optimistically show message in UI
                setMessages(prev => [...prev, { ...data, self: true }]);
                playSound('send');
            };

            const handleIncomingData = (data) => {
                // Handle CHUNKED data
                if (data.type === 'CHUNK') {
                    if (!fileChunksRef.current[data.id]) {
                        fileChunksRef.current[data.id] = new Array(data.total);
                    }
                    
                    fileChunksRef.current[data.id][data.current] = data.data;

                    if (data.current === data.total - 1) {
                        // Reconstruct
                        const fullContent = fileChunksRef.current[data.id].join('');
                        const originalMsg = { 
                            ...data.meta, 
                            content: fullContent, 
                            self: false 
                        };
                        
                        setMessages(prev => [...prev, originalMsg]);
                        playSound('receive');
                        delete fileChunksRef.current[data.id];
                    }
                    return; 
                }

                // Handle Legacy/Direct small messages
                let parsedData = data;
                if (typeof data === 'string') {
                    try {
                        parsedData = JSON.parse(data);
                    } catch (e) { return; }
                }
                setMessages(prev => [...prev, { ...parsedData, self: false }]);
                playSound('receive');
            };

            const connectToPeer = () => {
                const cleanId = targetPeerId.trim();
                if (!cleanId || !peerRef.current) return;
                if (cleanId === myPeerId) {
                    setStatus("ERROR: CANNOT LINK TO SELF");
                    setTimeout(() => setStatus("SYSTEM ONLINE. WAITING..."), 2000);
                    return;
                }

                setIsConnecting(true);
                setStatus(`SEARCHING: ${cleanId.substr(0,5)}...`);
                
                try {
                    const connection = peerRef.current.connect(cleanId, {
                        reliable: true,
                        serialization: 'json' // We handle chunking manually now
                    });
                    
                    if (!connection) {
                        setStatus("ERROR: CONNECTION FAILED");
                        setIsConnecting(false);
                        return;
                    }

                    setupConnection(connection);

                    connectionTimeoutRef.current = setTimeout(() => {
                        if (!connection.open) {
                            setStatus("TIMEOUT. CHECK ID & RETRY.");
                            setIsConnecting(false);
                            connection.close();
                        }
                    }, 8000); 

                } catch (e) {
                    console.error(e);
                    setStatus("CRITICAL ERROR");
                    setIsConnecting(false);
                }
            };

            const startCall = async () => {
                if (!conn) return;
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert("CALL FAILED: Camera access blocked. HTTPS Required.");
                    return;
                }
                try {
                    const constraints = { audio: true, video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } } };
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    setLocalStream(stream);
                    setCallStatus('calling');
                    
                    const call = peerRef.current.call(conn.peer, stream);
                    currentCallRef.current = call;
                    
                    call.on('stream', (remoteStream) => {
                        setRemoteStream(remoteStream);
                        setCallStatus('connected');
                    });
                    call.on('close', () => endCall());
                    call.on('error', () => endCall());
                } catch (err) {
                    alert(`CAMERA ERROR: ${err.message}`);
                    endCall();
                }
            };

            const answerCall = async () => {
                if (!incomingCall) return;
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert("ANSWER FAILED: Camera access blocked. HTTPS Required.");
                    return;
                }
                try {
                     const constraints = { audio: true, video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } } };
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    setLocalStream(stream);
                    
                    incomingCall.answer(stream);
                    currentCallRef.current = incomingCall;
                    setCallStatus('connected');
                    
                    incomingCall.on('stream', (remoteStream) => {
                        setRemoteStream(remoteStream);
                    });
                    incomingCall.on('close', () => endCall());
                } catch (err) {
                    alert(`CAMERA ERROR: ${err.message}`);
                    endCall();
                }
            };

            const endCall = () => {
                if (currentCallRef.current) currentCallRef.current.close();
                if (localStream) localStream.getTracks().forEach(track => track.stop());
                setLocalStream(null);
                setRemoteStream(null);
                setIncomingCall(null);
                setCallStatus('idle');
            };

            const sendMessage = (e) => {
                e && e.preventDefault();
                if (!inputMsg.trim() || !conn) return;

                const msgData = {
                    type: 'text',
                    content: inputMsg,
                    timestamp: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})
                };

                sendSmart(msgData);
                setInputMsg('');
            };

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file || !conn) return;
                
                // Limit to 200MB to prevent browser crash, but "Unlimited" logic applies to transport
                if (file.size > 200 * 1024 * 1024) {
                    alert("BROWSER SAFETY WARNING: Files > 200MB may crash the tab. Proceeding anyway.");
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    let fileType = 'application';
                    if (file.type.startsWith('image/')) fileType = 'image';
                    else if (file.type.startsWith('audio/')) fileType = 'audio';
                    else if (file.type.startsWith('video/')) fileType = 'video';
                    
                    const msgData = {
                        type: 'file',
                        fileType: fileType, 
                        mimeType: file.type,
                        content: event.target.result,
                        fileName: file.name,
                        fileSize: (file.size / 1024).toFixed(1) + 'KB',
                        timestamp: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})
                    };
                    sendSmart(msgData);
                };
                reader.readAsDataURL(file);
            };

            const toggleRecording = async () => {
                if (isRecording) {
                    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
                        mediaRecorderRef.current.stop();
                    }
                    setIsRecording(false);
                } else {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        const mediaRecorder = new MediaRecorder(stream);
                        mediaRecorderRef.current = mediaRecorder;
                        audioChunksRef.current = [];

                        mediaRecorder.ondataavailable = (event) => {
                            audioChunksRef.current.push(event.data);
                        };

                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
                            const reader = new FileReader();
                            reader.readAsDataURL(audioBlob);
                            reader.onloadend = () => {
                                const base64Audio = reader.result;
                                const msgData = {
                                    type: 'voice',
                                    content: base64Audio,
                                    timestamp: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})
                                };
                                if (conn) sendSmart(msgData);
                            };
                            stream.getTracks().forEach(track => track.stop());
                        };
                        mediaRecorder.start();
                        setIsRecording(true);
                    } catch (err) {
                        alert("MICROPHONE ERROR");
                    }
                }
            };

            const copyId = () => {
                const textArea = document.createElement("textarea");
                textArea.value = myPeerId;
                textArea.style.position = "fixed";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    alert("IDENTITY COPIED");
                } catch (err) {}
                document.body.removeChild(textArea);
            };

            const resetSystem = () => {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    setLocalStream(null);
                }
                endCall();
                setConn(null);
                setMessages([]);
                setTargetPeerId('');
                setStatus('SYSTEM RESETTING...');
                initializePeer();
            };

            // Icons
            const IconSend = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>;
            const IconPaperclip = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>;
            const IconMic = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>;
            const IconFile = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>;
            const IconCopy = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>;
            const IconPhone = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>;
            const IconPhoneOff = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v.01"></path><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><path d="M14.09 14.09l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92"></path></svg>;
            const IconRefresh = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>;

            return (
                <div className="flex h-[100dvh] w-full items-center justify-center p-2 md:p-4 relative z-20">
                    <ThreeBackground />
                    <div className="scan-line"></div>
                    
                    {/* INCOMING CALL MODAL */}
                    {callStatus === 'ringing' && incomingCall && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm">
                            <div className="bg-black border-2 border-green-500 p-6 max-w-sm w-full text-center shadow-[0_0_30px_rgba(0,255,65,0.3)]">
                                <h2 className="text-xl font-bold text-green-400 mb-4 animate-pulse">INCOMING TRANSMISSION</h2>
                                <div className="text-green-600 mb-6 font-mono text-xs">{incomingCall.peer}</div>
                                <div className="flex gap-4 justify-center">
                                    <button onClick={answerCall} className="sci-fi-btn p-4 rounded-full border-green-400 text-green-400 hover:bg-green-500 hover:text-black">
                                        <IconPhone />
                                    </button>
                                    <button onClick={() => {incomingCall.close(); setCallStatus('idle'); setIncomingCall(null);}} className="sci-fi-btn p-4 rounded-full border-red-500 text-red-500 hover:bg-red-600 hover:text-black">
                                        <IconPhoneOff />
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* VIDEO CALL OVERLAY - Mobile Optimized */}
                    {(callStatus === 'connected' || callStatus === 'calling') && (
                        <div className="video-overlay">
                            <div className="video-container">
                                {callStatus === 'calling' && (
                                    <div className="absolute text-green-500 animate-pulse text-xl font-bold z-10 text-center px-4">
                                        ESTABLISHING UPLINK...<br/><span className="text-xs text-green-700">Waiting for remote stream</span>
                                    </div>
                                )}
                                <video ref={remoteVideoRef} autoPlay playsInline className="remote-video bg-black/50" />
                                <video ref={localVideoRef} autoPlay playsInline muted className="local-video" />
                                
                                <div className="call-controls">
                                    <button onClick={endCall} className="call-btn-circle bg-red-900/80 border-red-500 text-red-500 hover:bg-red-600 hover:text-black">
                                        <IconPhoneOff size={32} />
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="w-full max-w-5xl h-full md:h-[90vh] flex flex-col md:flex-row gap-4 sci-fi-border p-2 md:p-4 bg-black/80">
                        {/* Mobile Tabs */}
                        <div className="md:hidden flex w-full gap-2 mb-2 shrink-0">
                            <button onClick={() => setMobileView('connect')} className={`flex-1 p-2 text-sm border border-green-500 uppercase ${mobileView === 'connect' ? 'tab-active' : 'bg-black/50 text-green-500'}`}>Connection</button>
                            <button onClick={() => setMobileView('chat')} className={`flex-1 p-2 text-sm border border-green-500 uppercase ${mobileView === 'chat' ? 'tab-active' : 'bg-black/50 text-green-500'}`}>Comms</button>
                        </div>

                        {/* Connection Panel */}
                        <div className={`${mobileView === 'connect' ? 'flex' : 'hidden'} md:flex w-full md:w-1/3 flex-col gap-4 border-r border-green-900/50 pr-0 md:pr-4 h-full`}>
                            <div className="p-3 border border-green-900 bg-black/50 shrink-0">
                                <h2 className="text-lg font-bold mb-2 tracking-widest text-green-400 border-b border-green-900 pb-2">IDENTITY NODE</h2>
                                <div className="text-[10px] text-green-600 mb-1">YOUR ACCESS CODE</div>
                                <div className="flex items-center gap-2 mb-2">
                                    <code className="flex-1 bg-green-900/20 p-2 text-xs md:text-sm break-all border border-green-800 text-green-300 font-mono">{myPeerId || 'GENERATING...'}</code>
                                    <button onClick={copyId} className="sci-fi-btn p-2 shrink-0" title="Copy ID"><IconCopy /></button>
                                    <button onClick={resetSystem} className="sci-fi-btn p-2 shrink-0 border-yellow-600 text-yellow-500 hover:bg-yellow-600 hover:text-black" title="Reset System"><IconRefresh /></button>
                                </div>
                                <div className="text-[10px] text-green-700 uppercase">Status: <span className={myPeerId ? "text-green-400" : "text-yellow-500"}>{myPeerId ? "ACTIVE" : "OFFLINE"}</span></div>
                            </div>

                            <div className="p-3 border border-green-900 bg-black/50 flex-1 flex flex-col min-h-0 overflow-y-auto">
                                <h2 className="text-lg font-bold mb-4 tracking-widest text-green-400 border-b border-green-900 pb-2">TARGET LINK</h2>
                                {!conn ? (
                                    <div className="flex flex-col gap-3">
                                        <div className="text-[10px] text-green-600">ENTER TARGET NODE ID</div>
                                        <input type="text" value={targetPeerId} onChange={(e) => setTargetPeerId(e.target.value)} placeholder="Paste code..." className="sci-fi-input p-3 w-full text-sm rounded-none" disabled={isConnecting} />
                                        <button onClick={connectToPeer} disabled={!targetPeerId || !myPeerId || isConnecting} className="sci-fi-btn py-3 font-bold tracking-widest mt-2 flex justify-center items-center gap-2">
                                            {isConnecting ? <div className="loader"></div> : "INITIALIZE LINK"}
                                        </button>
                                    </div>
                                ) : (
                                    <div className="flex flex-col gap-2 items-center justify-center flex-1 text-center">
                                        <div className="w-12 h-12 border-2 border-green-500 rounded-full flex items-center justify-center animate-pulse"><div className="w-8 h-8 bg-green-500/20 rounded-full"></div></div>
                                        <div className="font-bold text-green-400 mt-2">LINKED SECURELY</div>
                                        <div className="text-[10px] text-green-600 font-mono break-all px-2">{conn.peer}</div>
                                        <button onClick={() => {conn.close(); setConn(null);}} className="mt-4 text-[10px] text-red-500 hover:text-red-400 border border-red-900 hover:border-red-500 px-4 py-2 uppercase bg-transparent transition-colors">Sever Connection</button>
                                    </div>
                                )}
                                <div className="mt-auto pt-4 text-[9px] text-green-800 font-mono"><p>PROTOCOL: WEBRTC P2P</p><p>ENCRYPTION: AES-128 GCM</p><p>SERVER: NONE (DIRECT)</p></div>
                            </div>
                        </div>

                        {/* Chat Panel */}
                        <div className={`${mobileView === 'chat' ? 'flex' : 'hidden'} md:flex flex-1 flex-col relative bg-black/20 h-full min-h-0`}>
                            {/* Header with Call Button */}
                            <div className="flex justify-between items-center p-2 border-b border-green-900 bg-green-900/10 shrink-0">
                                <div className="font-bold text-green-400 tracking-wider text-xs md:text-sm flex items-center gap-2 truncate">
                                    <span className={`w-2 h-2 shrink-0 rounded-full ${conn ? 'bg-green-500 animate-pulse' : 'bg-red-500'}`}></span>
                                    {status}
                                </div>
                                <div className="flex items-center gap-2">
                                    {conn && (
                                        <button onClick={startCall} className="sci-fi-btn p-1 px-3 text-[10px] gap-1 border-green-500 text-green-400 hover:bg-green-500 hover:text-black">
                                            <IconPhone /> CALL
                                        </button>
                                    )}
                                    <div className="text-[10px] text-green-700 font-mono hidden sm:block">ENCRYPTED // V.2.2.0</div>
                                </div>
                            </div>

                            {/* Messages Area */}
                            <div className="flex-1 overflow-y-auto p-2 md:p-4 space-y-3 font-sans relative">
                                {messages.length === 0 && (
                                    <div className="absolute inset-0 flex items-center justify-center opacity-20 pointer-events-none">
                                        <div className="text-center"><div className="text-4xl md:text-6xl mb-2">NO DATA</div><div className="text-xs tracking-widest">WAITING FOR TRANSMISSION</div></div>
                                    </div>
                                )}
                                {messages.map((msg, idx) => (
                                    <div key={idx} className={`flex ${msg.self ? 'justify-end' : 'justify-start'}`}>
                                        <div className={`message-bubble p-2 md:p-3 border ${msg.self ? 'border-green-500 bg-green-900/20 text-right rounded-l-lg rounded-br-lg' : 'border-cyan-500 bg-cyan-900/20 text-left rounded-r-lg rounded-bl-lg'}`}>
                                            <div className={`text-[9px] mb-1 font-mono ${msg.self ? 'text-green-600' : 'text-cyan-600'}`}>{msg.self ? 'YOU' : 'REMOTE'} // {msg.timestamp}</div>
                                            {msg.type === 'text' && <div className="text-sm font-mono text-white/90 break-words">{msg.content}</div>}
                                            {msg.type === 'file' && msg.fileType === 'image' && <div className="mt-1"><img src={msg.content} alt="Transferred" className="max-w-full rounded border border-green-500/50" /></div>}
                                            {msg.type === 'voice' && <div className="mt-1 flex items-center gap-2"><audio controls src={msg.content} className="h-8 max-w-[200px]" /><div className="text-[10px] uppercase text-green-500">Voice Note</div></div>}
                                            {(msg.type === 'file' && msg.fileType !== 'image') && (
                                                <div className="mt-1 p-2 bg-black/40 border border-dashed border-green-500/50 rounded flex items-center gap-3">
                                                    <div className="p-2 bg-green-900/30 rounded"><IconFile /></div>
                                                    <div className="text-left overflow-hidden"><div className="text-xs text-green-300 truncate max-w-[150px]">{msg.fileName}</div><div className="text-[9px] text-green-600">{msg.fileSize}</div></div>
                                                    <a href={msg.content} download={msg.fileName} className="ml-auto sci-fi-btn p-1 px-3 text-[10px] h-6">SAVE</a>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                ))}
                                <div ref={messagesEndRef} />
                            </div>

                            {/* Upload Progress Bar */}
                            {uploadProgress > 0 && (
                                <div className="px-3 pb-1 bg-black/80 border-t border-green-900">
                                    <div className="text-[10px] text-green-500 mb-1">ENCRYPTING & UPLOADING... {uploadProgress}%</div>
                                    <div className="progress-bar-container">
                                        <div className="progress-bar" style={{width: `${uploadProgress}%`}}></div>
                                    </div>
                                </div>
                            )}

                            {/* Input Area */}
                            <div className="p-2 md:p-3 border-t border-green-900 bg-black/80 shrink-0">
                                <form onSubmit={sendMessage} className="flex gap-2 items-end">
                                    <label className="sci-fi-btn w-10 h-10 md:w-12 md:h-12 flex-shrink-0 flex items-center justify-center rounded-none" title="Send File (Any Type)">
                                        <input type="file" className="hidden" onChange={handleFileUpload} disabled={!conn} />
                                        <IconPaperclip />
                                    </label>
                                    <button type="button" onClick={toggleRecording} disabled={!conn} className={`sci-fi-btn w-10 h-10 md:w-12 md:h-12 flex-shrink-0 rounded-none ${isRecording ? 'recording-pulse' : ''}`} title={isRecording ? "Stop & Send" : "Record Voice"}><IconMic /></button>
                                    <div className="flex-1 relative">
                                        {isRecording && <div className="absolute inset-0 bg-red-900/80 flex items-center justify-center text-red-200 text-xs tracking-widest animate-pulse border border-red-500 z-10 pointer-events-none">RECORDING AUDIO...</div>}
                                        <input type="text" value={inputMsg} onChange={(e) => setInputMsg(e.target.value)} placeholder={conn ? "Message..." : "Waiting..."} disabled={!conn || isRecording} className="sci-fi-input w-full p-2 md:p-3 h-10 md:h-12 text-sm disabled:opacity-50" />
                                    </div>
                                    <button type="submit" disabled={!conn || isRecording} className="sci-fi-btn w-12 h-10 md:w-auto md:h-12 md:px-6 font-bold flex items-center justify-center gap-2 rounded-none"><span className="hidden md:inline">SEND</span> <IconSend /></button>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
